package HomeWork4;
/**
 * Сыпченко Алексей
 * ДЗ №4
 *
 * Task1.
 * Задача про короля, но с препятствиями, описанными в матрице
 * 0- препятствие, 1 - проход разрешен
 * Пусть за один ход королю разрешается передвинуться на одну клетку вниз или вправо. Необходимо
 * определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний
 * угол. Будем считать, что положение короля задается парой чисел (a, b), где a задаёт номер строки, а
 * b — номер столбца. Строки нумеруются сверху вниз от 0 до n − 1, а столбцы — слева направо от 0 до
 * m − 1. Таким образом, первоначальное положение короля — клетка (0, 0), а конечное — клетка (n − 1,
 * m − 1).
 *
 * Task2.
 * Решить задачу о нахождении длины наибольшей общей подпоследовательности с помощью матрицы.
 *
 * Task3.
 * У исполнителя Калькулятор две команды, которым присвоены номера:
 * 1. прибавь 1.
 * 2. умножь на 2.
 * Сколько есть программ, которые число 1 преобразуют в число 16?
 *
 * Task4.
 * Пусть за один ход королю разрешается передвинуться на одну клетку вниз или вправо. Необходимо
 * определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний
 * угол. Будем считать, что положение короля задается парой чисел (a, b), где a задаёт номер строки, а
 * b — номер столбца. Строки нумеруются сверху вниз от 0 до n − 1, а столбцы — слева направо от 0 до
 * m − 1. Таким образом, первоначальное положение короля — клетка (0, 0), а конечное — клетка (n − 1,
 * m − 1).
 *
 */

import java.util.Scanner;

public class HomeWork4 {
    Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        HomeWork4 homeWork4 = new HomeWork4();
        int sel = 0;
        do {
            homeWork4.menu();
            sel = homeWork4.scanner.nextInt();
            switch (sel) {
                case 1: {
                    homeWork4.solution1();
                    break;
                }
                case 2: {
                    homeWork4.solution2();
                    break;
                }
                case 3: {
                    homeWork4.solution3();
                    break;
                }
                case 4: {
                    homeWork4.solution4();
                    break;
                }
                case 0: {
                    System.out.println("Bye-bye");
                    break;
                }
                default:
                    System.out.println("Wrong selected");
            }
        } while (sel != 0);
    }

    public void menu() {
        System.out.println();
        for (int i = 1; i < 6; i++) {
            System.out.println(i + " task");
        }
        System.out.println("0 - exit");
    }


    /**
     * 1. Задача про короля, но с препятствиями, описанными в матрице
     * 0- препятствие, 1 - проход разрешен
     * Пусть за один ход королю разрешается передвинуться на одну клетку вниз или вправо. Необходимо
     * определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний
     * угол. Будем считать, что положение короля задается парой чисел (a, b), где a задаёт номер строки, а
     * b — номер столбца. Строки нумеруются сверху вниз от 0 до n − 1, а столбцы — слева направо от 0 до
     * m − 1. Таким образом, первоначальное положение короля — клетка (0, 0), а конечное — клетка (n − 1,
     * m − 1).
     */

    public void solution1() {
        //карта препятствий
        int[][] map = new int[][]{
                {1, 1, 0, 0, 1, 1, 0, 1},
                {1, 0, 1, 1, 0, 0, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1},
                {0, 1, 1, 1, 0, 1, 1, 1},
                {1, 1, 1, 1, 1, 1, 1, 1},
                {1, 0, 1, 0, 1, 0, 1, 0},
                {1, 1, 1, 0, 1, 1, 1, 1},
                {0, 1, 1, 1, 1, 1, 1, 1}
        };

//        int map[][] = new int[][]{
//                {1, 1, 1},
//                {0, 1, 0},
//                {1, 1, 1}
//        };
        int m = 8, n = 8; // размер шахматного поля
        int field[][] = new int[n][m];// массив для шахматного поля
        // проверка возможности начать и закончить ходьбу короля
        // если в карте препятствий map[0][0] = 0 - король не может стоять в клетке [0][0]
        if (map[0][0] == 0) {
            System.out.println("Судя по карте препятствий король не может находиться в клетке field[0][0]");
            return;
        }
        //если в карте препятствий map[n][m] = 0 - король не сможет дойти до правого нижнего угла
        else if (map[n - 1][m - 1] == 0) {
            System.out.println("Судя по карте препятствий король не сможет дойти до правого нижнего угла");
            return;
        }
        field[0][0] = 1; //ставлю короля в начальную позицию
        //заполняю первую строку
        for (int i = 1; i < m; i++) {
            // если в первой строке карты препятствий map в текущей ячейке 1 (проход разрешен) и в клетку
            // левее мог походить король, тогда пишем 1
            if (map[0][i] != 0 && field[0][i - 1] != 0) field[0][i] = 1;
            else field[0][i] = 0;
        }
        for (int i = 1; i < n; i++) { // обход остальных строк
            if (map[i][0] != 0 && field[i - 1][0] != 0) field[i][0] = 1;
            else field[i][0] = 0;
            for (int j = 1; j < m; j++) { // проход по строке
                int way1 = 0, way2 = 0;
                if (map[i][j] != 0) {
                    if (map[i][j - 1] != 0) way1 = field[i][j - 1];
                    if (map[i - 1][j] != 0) way2 = field[i - 1][j];
                    field[i][j] = way1 + way2;
                }
                //field[i][j] = way1 + way2+field[i-1][j-1]; // + по диагонали слева направо вниз без учета препятствий
            }
        }
        // вывод поля с количеством путей
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                System.out.format("%6s", field[i][j]);
            }
            System.out.println();
        }
    }

    // 2. Решить задачу о нахождении длины наибольшей общей подпоследовательности с помощью матрицы.
    public void solution2() {
        String str1 = "Geekminds";
        String str2 = "Geekbrains";
        // преобразую строки в символьные массивы
        char a[] = convertStringToChar(str1);
        char b[] = convertStringToChar(str2);
        int row = a.length, col = b.length;
        //создаю матрицу
        int map[][] = new int[row + 1][col + 1];
        for (int i = 0; i < col; i++) {
            map[0][i] = 0; // заполняю первую строку нулями
        }
        for (int i = 0; i < row; i++) {
            map[i][0] = 0; // заполняю первы столбец нулями
        }
        map = compare(a, b, row, col, map);
        // печатаю матрицу
        for (int i = 0; i < row + 1; i++) {
            for (int j = 0; j < col + 1; j++) {
                System.out.format("%3d", map[i][j]);
            }
            System.out.println();
        }
        System.out.println("Наибольшая общая длина подпоследовательности - " + map[row][col]);
    }

    // сравнение двух строк
    public int[][] compare(char[] a, char[] b, int row, int col, int[][] map) {
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (a[i] == b[j]) {
                    map[i + 1][j + 1] = 1 + map[i][j];
                } else map[i + 1][j + 1] = Math.max(map[i][j + 1], map[i + 1][j]);
            }
        }
        return map;
    }

    // преобразую слово в массив символов
    public char[] convertStringToChar(String str) {
        return str.toCharArray();
    }

    /**
     * 3. У исполнителя Калькулятор две команды, которым присвоены номера:
     * 1. прибавь 1.
     * 2. умножь на 2.
     * Сколько есть программ, которые число 1 преобразуют в число 16?
     */
    public void solution3() {
        int number = 16;
        System.out.println(tree(number));
    }

    public long tree(int number) {
        if (number < 1) return 0;
        if (number == 1) return 1;
        else if (number % 2 == 0) return tree(number / 2) + tree(number - 1);
        else return tree(number - 1);
    }

    /**
     * 4 Пусть за один ход королю разрешается передвинуться на одну клетку вниз или вправо. Необходимо
     * определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний
     * угол. Будем считать, что положение короля задается парой чисел (a, b), где a задаёт номер строки, а
     * b — номер столбца. Строки нумеруются сверху вниз от 0 до n − 1, а столбцы — слева направо от 0 до
     * m − 1. Таким образом, первоначальное положение короля — клетка (0, 0), а конечное — клетка (n − 1,
     * m − 1).
     */
    public void solution4() {
        int m = 8, n = 8;
        int field[][] = new int[n][m];
        for (int i = 0; i < m; i++) field[0][i] = 1;
        for (int i = 1; i < n; i++) {
            field[i][0] = 1;
            for (int j = 1; j < m; j++) {
                field[i][j] = field[i][j - 1] + field[i - 1][j];
                //field[i][j] = field[i][j - 1] + field[i - 1][j]+field[i-1][j-1]; // + по диагонали слева направо вниз
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                System.out.format("%6s", field[i][j]);
            }
            System.out.println();
        }
    }
}